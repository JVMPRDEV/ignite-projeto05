import {
  require_build
} from "./chunk-ACEZ3SSW.js";
import "./chunk-BKLCY3MB.js";
import "./chunk-6AMIYDZK.js";
import "./chunk-JKQEB2HT.js";
import {
  addons
} from "./chunk-KYT6TJGM.js";
import "./chunk-7DN4YUXE.js";
import "./chunk-YVEEV5MS.js";
import "./chunk-N4OU44MP.js";
import "./chunk-66X6BCQU.js";
import "./chunk-CKIBD2RD.js";
import "./chunk-PXKLPDSH.js";
import {
  FORCE_REMOUNT,
  IGNORED_EXCEPTION,
  SET_CURRENT_STORY,
  STORY_RENDER_PHASE_CHANGED
} from "./chunk-AESLGWHI.js";
import "./chunk-PTJ6TCCX.js";
import "./chunk-627YFXPD.js";
import {
  require_symbol_define_to_primitive,
  require_well_known_symbol_define
} from "./chunk-L3SKGDWI.js";
import "./chunk-XJ2JJV6N.js";
import "./chunk-LMMZB5YI.js";
import "./chunk-PFA5ARSF.js";
import "./chunk-E6FELHDU.js";
import "./chunk-U7UCLSQI.js";
import "./chunk-NIAN2TDC.js";
import "./chunk-NEK5IPCF.js";
import "./chunk-WRNXHNZR.js";
import "./chunk-63CEWH4T.js";
import "./chunk-EU3NVPBZ.js";
import {
  once,
  require_es_regexp_exec
} from "./chunk-5CNPPXEO.js";
import {
  require_es_array_iterator,
  require_es_string_iterator
} from "./chunk-5JKXEZBY.js";
import {
  require_an_object,
  require_define_built_in,
  require_has_own_property,
  require_ordinary_to_primitive,
  require_well_known_symbol
} from "./chunk-D2M6HF7H.js";
import {
  require_window
} from "./chunk-IPOUH34V.js";
import {
  __commonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// ../../node_modules/core-js/internals/date-to-primitive.js
var require_date_to_primitive = __commonJS({
  "../../node_modules/core-js/internals/date-to-primitive.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var $TypeError = TypeError;
    module.exports = function(hint) {
      anObject(this);
      if (hint === "string" || hint === "default")
        hint = "string";
      else if (hint !== "number")
        throw $TypeError("Incorrect hint");
      return ordinaryToPrimitive(this, hint);
    };
  }
});

// ../../node_modules/@storybook/addon-interactions/dist/esm/preset/preview.js
var import_es_array_iterator2 = __toESM(require_es_array_iterator());
var import_es_string_iterator2 = __toESM(require_es_string_iterator());
var import_es_regexp_exec2 = __toESM(require_es_regexp_exec());

// ../../node_modules/core-js/modules/es.symbol.to-primitive.js
var defineWellKnownSymbol = require_well_known_symbol_define();
var defineSymbolToPrimitive = require_symbol_define_to_primitive();
defineWellKnownSymbol("toPrimitive");
defineSymbolToPrimitive();

// ../../node_modules/core-js/modules/es.date.to-primitive.js
var hasOwn = require_has_own_property();
var defineBuiltIn = require_define_built_in();
var dateToPrimitive = require_date_to_primitive();
var wellKnownSymbol = require_well_known_symbol();
var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
var DatePrototype = Date.prototype;
if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
  defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}

// ../../node_modules/@storybook/instrumenter/dist/esm/instrumenter.js
var import_es_array_iterator = __toESM(require_es_array_iterator());
var import_es_string_iterator = __toESM(require_es_string_iterator());
var import_es_regexp_exec = __toESM(require_es_regexp_exec());
var import_global = __toESM(require_window());

// ../../node_modules/@storybook/instrumenter/dist/esm/types.js
var CallStates;
(function(CallStates2) {
  CallStates2["DONE"] = "done";
  CallStates2["ERROR"] = "error";
  CallStates2["ACTIVE"] = "active";
  CallStates2["WAITING"] = "waiting";
})(CallStates || (CallStates = {}));

// ../../node_modules/@storybook/instrumenter/dist/esm/instrumenter.js
var _global$FEATURES;
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var EVENTS = {
  CALL: "instrumenter/call",
  SYNC: "instrumenter/sync",
  START: "instrumenter/start",
  BACK: "instrumenter/back",
  GOTO: "instrumenter/goto",
  NEXT: "instrumenter/next",
  END: "instrumenter/end"
};
var debuggerDisabled = ((_global$FEATURES = import_global.default.FEATURES) === null || _global$FEATURES === void 0 ? void 0 : _global$FEATURES.interactionsDebugger) !== true;
var controlsDisabled = {
  debugger: !debuggerDisabled,
  start: false,
  back: false,
  goto: false,
  next: false,
  end: false
};
var alreadyCompletedException = new Error("This function ran after the play function completed. Did you forget to `await` it?");
var isObject = function isObject2(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
};
var isModule = function isModule2(o) {
  return Object.prototype.toString.call(o) === "[object Module]";
};
var isInstrumentable = function isInstrumentable2(o) {
  if (!isObject(o) && !isModule(o))
    return false;
  if (o.constructor === void 0)
    return true;
  var proto = o.constructor.prototype;
  if (!isObject(proto))
    return false;
  if (Object.prototype.hasOwnProperty.call(proto, "isPrototypeOf") === false)
    return false;
  return true;
};
var construct = function construct2(obj) {
  try {
    return new obj.constructor();
  } catch (e) {
    return {};
  }
};
var getInitialState = function getInitialState2() {
  return {
    renderPhase: void 0,
    isDebugging: false,
    isPlaying: false,
    isLocked: false,
    cursor: 0,
    calls: [],
    shadowCalls: [],
    callRefsByResult: /* @__PURE__ */ new Map(),
    chainedCallIds: /* @__PURE__ */ new Set(),
    parentId: void 0,
    playUntil: void 0,
    resolvers: {},
    syncTimeout: void 0,
    forwardedException: void 0
  };
};
var getRetainedState = function getRetainedState2(state) {
  var isDebugging = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var calls = (isDebugging ? state.shadowCalls : state.calls).filter(function(call) {
    return call.retain;
  });
  if (!calls.length)
    return void 0;
  var callRefsByResult = new Map(Array.from(state.callRefsByResult.entries()).filter(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), ref = _ref2[1];
    return ref.retain;
  }));
  return {
    cursor: calls.length,
    calls,
    callRefsByResult
  };
};
var Instrumenter = function() {
  function Instrumenter2() {
    var _this = this;
    _classCallCheck(this, Instrumenter2);
    this.channel = void 0;
    this.initialized = false;
    this.state = void 0;
    this.channel = addons.getChannel();
    this.state = import_global.default.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
    var resetState = function resetState2(_ref3) {
      var storyId = _ref3.storyId, _ref3$isPlaying = _ref3.isPlaying, isPlaying = _ref3$isPlaying === void 0 ? true : _ref3$isPlaying, _ref3$isDebugging = _ref3.isDebugging, isDebugging = _ref3$isDebugging === void 0 ? false : _ref3$isDebugging;
      var state = _this.getState(storyId);
      _this.setState(storyId, Object.assign({}, getInitialState(), getRetainedState(state, isDebugging), {
        shadowCalls: isDebugging ? state.shadowCalls : [],
        chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: isDebugging ? state.playUntil : void 0,
        isPlaying,
        isDebugging
      }));
      if (!isDebugging)
        _this.sync(storyId);
    };
    this.channel.on(FORCE_REMOUNT, resetState);
    this.channel.on(STORY_RENDER_PHASE_CHANGED, function(_ref4) {
      var storyId = _ref4.storyId, newPhase = _ref4.newPhase;
      var _this$getState = _this.getState(storyId), isDebugging = _this$getState.isDebugging, forwardedException = _this$getState.forwardedException;
      _this.setState(storyId, {
        renderPhase: newPhase
      });
      if (newPhase === "playing") {
        resetState({
          storyId,
          isDebugging
        });
      }
      if (newPhase === "played") {
        _this.setState(storyId, {
          isLocked: false,
          isPlaying: false,
          isDebugging: false,
          forwardedException: void 0
        });
        if (forwardedException)
          throw forwardedException;
      }
    });
    this.channel.on(SET_CURRENT_STORY, function() {
      if (_this.initialized)
        _this.cleanup();
      else
        _this.initialized = true;
    });
    var start = function start2(_ref5) {
      var storyId = _ref5.storyId, playUntil = _ref5.playUntil;
      if (!_this.getState(storyId).isDebugging) {
        _this.setState(storyId, function(_ref6) {
          var calls = _ref6.calls;
          return {
            calls: [],
            shadowCalls: calls.map(function(call) {
              return Object.assign({}, call, {
                status: CallStates.WAITING
              });
            }),
            isDebugging: true
          };
        });
      }
      var log = _this.getLog(storyId);
      _this.setState(storyId, function(_ref7) {
        var _shadowCalls$slice$fi;
        var shadowCalls = _ref7.shadowCalls;
        var firstRowIndex = shadowCalls.findIndex(function(call) {
          return call.id === log[0].callId;
        });
        return {
          playUntil: playUntil || ((_shadowCalls$slice$fi = shadowCalls.slice(0, firstRowIndex).filter(function(call) {
            return call.interceptable;
          }).slice(-1)[0]) === null || _shadowCalls$slice$fi === void 0 ? void 0 : _shadowCalls$slice$fi.id)
        };
      });
      _this.channel.emit(FORCE_REMOUNT, {
        storyId,
        isDebugging: true
      });
    };
    var back = function back2(_ref8) {
      var _log;
      var storyId = _ref8.storyId;
      var _this$getState2 = _this.getState(storyId), isDebugging = _this$getState2.isDebugging;
      var log = _this.getLog(storyId);
      var next2 = isDebugging ? log.findIndex(function(_ref9) {
        var status = _ref9.status;
        return status === CallStates.WAITING;
      }) : log.length;
      start({
        storyId,
        playUntil: (_log = log[next2 - 2]) === null || _log === void 0 ? void 0 : _log.callId
      });
    };
    var goto = function goto2(_ref10) {
      var storyId = _ref10.storyId, callId = _ref10.callId;
      var _this$getState3 = _this.getState(storyId), calls = _this$getState3.calls, shadowCalls = _this$getState3.shadowCalls, resolvers = _this$getState3.resolvers;
      var call = calls.find(function(_ref11) {
        var id = _ref11.id;
        return id === callId;
      });
      var shadowCall = shadowCalls.find(function(_ref12) {
        var id = _ref12.id;
        return id === callId;
      });
      if (!call && shadowCall && Object.values(resolvers).length > 0) {
        var _this$getLog$find;
        var nextId = (_this$getLog$find = _this.getLog(storyId).find(function(c) {
          return c.status === CallStates.WAITING;
        })) === null || _this$getLog$find === void 0 ? void 0 : _this$getLog$find.callId;
        if (shadowCall.id !== nextId)
          _this.setState(storyId, {
            playUntil: shadowCall.id
          });
        Object.values(resolvers).forEach(function(resolve) {
          return resolve();
        });
      } else {
        start({
          storyId,
          playUntil: callId
        });
      }
    };
    var next = function next2(_ref13) {
      var storyId = _ref13.storyId;
      var _this$getState4 = _this.getState(storyId), resolvers = _this$getState4.resolvers;
      if (Object.values(resolvers).length > 0) {
        Object.values(resolvers).forEach(function(resolve) {
          return resolve();
        });
      } else {
        var _this$getLog$find2;
        var nextId = (_this$getLog$find2 = _this.getLog(storyId).find(function(c) {
          return c.status === CallStates.WAITING;
        })) === null || _this$getLog$find2 === void 0 ? void 0 : _this$getLog$find2.callId;
        if (nextId)
          start({
            storyId,
            playUntil: nextId
          });
        else
          end({
            storyId
          });
      }
    };
    var end = function end2(_ref14) {
      var storyId = _ref14.storyId;
      _this.setState(storyId, {
        playUntil: void 0,
        isDebugging: false
      });
      Object.values(_this.getState(storyId).resolvers).forEach(function(resolve) {
        return resolve();
      });
    };
    this.channel.on(EVENTS.START, start);
    this.channel.on(EVENTS.BACK, back);
    this.channel.on(EVENTS.GOTO, goto);
    this.channel.on(EVENTS.NEXT, next);
    this.channel.on(EVENTS.END, end);
  }
  _createClass(Instrumenter2, [{
    key: "getState",
    value: function getState(storyId) {
      return this.state[storyId] || getInitialState();
    }
  }, {
    key: "setState",
    value: function setState(storyId, update) {
      var state = this.getState(storyId);
      var patch = typeof update === "function" ? update(state) : update;
      this.state = Object.assign({}, this.state, _defineProperty({}, storyId, Object.assign({}, state, patch)));
      import_global.default.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      this.state = Object.entries(this.state).reduce(function(acc, _ref15) {
        var _ref16 = _slicedToArray(_ref15, 2), storyId = _ref16[0], state = _ref16[1];
        var retainedState = getRetainedState(state);
        if (!retainedState)
          return acc;
        acc[storyId] = Object.assign(getInitialState(), retainedState);
        return acc;
      }, {});
      this.channel.emit(EVENTS.SYNC, {
        controlStates: controlsDisabled,
        logItems: []
      });
      import_global.default.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
    }
  }, {
    key: "getLog",
    value: function getLog(storyId) {
      var _this$getState5 = this.getState(storyId), calls = _this$getState5.calls, shadowCalls = _this$getState5.shadowCalls;
      var merged = _toConsumableArray(shadowCalls);
      calls.forEach(function(call, index) {
        merged[index] = call;
      });
      var seen = /* @__PURE__ */ new Set();
      return merged.reduceRight(function(acc, call) {
        call.args.forEach(function(arg) {
          if (arg !== null && arg !== void 0 && arg.__callId__) {
            seen.add(arg.__callId__);
          }
        });
        call.path.forEach(function(node) {
          if (node.__callId__) {
            seen.add(node.__callId__);
          }
        });
        if (call.interceptable && !seen.has(call.id)) {
          acc.unshift({
            callId: call.id,
            status: call.status
          });
          seen.add(call.id);
        }
        return acc;
      }, []);
    }
  }, {
    key: "instrument",
    value: function instrument2(obj, options) {
      var _this2 = this;
      if (!isInstrumentable(obj))
        return obj;
      var _options$mutate = options.mutate, mutate = _options$mutate === void 0 ? false : _options$mutate, _options$path = options.path, path = _options$path === void 0 ? [] : _options$path;
      return Object.keys(obj).reduce(function(acc, key) {
        var value = obj[key];
        if (typeof value !== "function") {
          acc[key] = _this2.instrument(value, Object.assign({}, options, {
            path: path.concat(key)
          }));
          return acc;
        }
        if (typeof value.__originalFn__ === "function") {
          acc[key] = value;
          return acc;
        }
        acc[key] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _this2.track(key, value, args, options);
        };
        acc[key].__originalFn__ = value;
        Object.defineProperty(acc[key], "name", {
          value: key,
          writable: false
        });
        if (Object.keys(value).length > 0) {
          Object.assign(acc[key], _this2.instrument(Object.assign({}, value), Object.assign({}, options, {
            path: path.concat(key)
          })));
        }
        return acc;
      }, mutate ? obj : construct(obj));
    }
  }, {
    key: "track",
    value: function track(method, fn2, args, options) {
      var _args$, _global$window$__STOR, _global$window$__STOR2, _global$window$__STOR3;
      var storyId = (args === null || args === void 0 ? void 0 : (_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$.__storyId__) || ((_global$window$__STOR = import_global.default.window.__STORYBOOK_PREVIEW__) === null || _global$window$__STOR === void 0 ? void 0 : (_global$window$__STOR2 = _global$window$__STOR.urlStore) === null || _global$window$__STOR2 === void 0 ? void 0 : (_global$window$__STOR3 = _global$window$__STOR2.selection) === null || _global$window$__STOR3 === void 0 ? void 0 : _global$window$__STOR3.storyId);
      var _this$getState6 = this.getState(storyId), cursor = _this$getState6.cursor, parentId = _this$getState6.parentId;
      this.setState(storyId, {
        cursor: cursor + 1
      });
      var id = "".concat(parentId || storyId, " [").concat(cursor, "] ").concat(method);
      var _options$path2 = options.path, path = _options$path2 === void 0 ? [] : _options$path2, _options$intercept = options.intercept, intercept = _options$intercept === void 0 ? false : _options$intercept, _options$retain = options.retain, retain = _options$retain === void 0 ? false : _options$retain;
      var interceptable = typeof intercept === "function" ? intercept(method, path) : intercept;
      var call = {
        id,
        parentId,
        storyId,
        cursor,
        path,
        method,
        args,
        interceptable,
        retain
      };
      var result = (interceptable ? this.intercept : this.invoke).call(this, fn2, call, options);
      return this.instrument(result, Object.assign({}, options, {
        mutate: true,
        path: [{
          __callId__: call.id
        }]
      }));
    }
  }, {
    key: "intercept",
    value: function intercept(fn2, call, options) {
      var _this3 = this;
      var _this$getState7 = this.getState(call.storyId), chainedCallIds = _this$getState7.chainedCallIds, isDebugging = _this$getState7.isDebugging, playUntil = _this$getState7.playUntil;
      var isChainedUpon = chainedCallIds.has(call.id);
      if (!isDebugging || isChainedUpon || playUntil) {
        if (playUntil === call.id) {
          this.setState(call.storyId, {
            playUntil: void 0
          });
        }
        return this.invoke(fn2, call, options);
      }
      return new Promise(function(resolve) {
        _this3.setState(call.storyId, function(_ref17) {
          var resolvers = _ref17.resolvers;
          return {
            isLocked: false,
            resolvers: Object.assign({}, resolvers, _defineProperty({}, call.id, resolve))
          };
        });
      }).then(function() {
        _this3.setState(call.storyId, function(state) {
          var _state$resolvers = state.resolvers, _call$id = call.id, _ = _state$resolvers[_call$id], resolvers = _objectWithoutProperties(_state$resolvers, [_call$id].map(_toPropertyKey));
          return {
            isLocked: true,
            resolvers
          };
        });
        return _this3.invoke(fn2, call, options);
      });
    }
  }, {
    key: "invoke",
    value: function invoke(fn2, call, options) {
      var _this4 = this;
      var _this$getState8 = this.getState(call.storyId), callRefsByResult = _this$getState8.callRefsByResult, forwardedException = _this$getState8.forwardedException, renderPhase = _this$getState8.renderPhase;
      var info = Object.assign({}, call, {
        args: call.args.map(function(arg) {
          if (callRefsByResult.has(arg)) {
            return callRefsByResult.get(arg);
          }
          if (arg instanceof import_global.default.window.HTMLElement) {
            var prefix = arg.prefix, localName = arg.localName, id = arg.id, classList = arg.classList, innerText = arg.innerText;
            var classNames = Array.from(classList);
            return {
              __element__: {
                prefix,
                localName,
                id,
                classNames,
                innerText
              }
            };
          }
          return arg;
        })
      });
      call.path.forEach(function(ref) {
        if (ref !== null && ref !== void 0 && ref.__callId__) {
          _this4.setState(call.storyId, function(_ref18) {
            var chainedCallIds = _ref18.chainedCallIds;
            return {
              chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
            };
          });
        }
      });
      var handleException = function handleException2(e) {
        if (e instanceof Error) {
          var name = e.name, message = e.message, stack = e.stack;
          var exception = {
            name,
            message,
            stack
          };
          _this4.update(Object.assign({}, info, {
            status: CallStates.ERROR,
            exception
          }));
          _this4.setState(call.storyId, function(state) {
            return {
              callRefsByResult: new Map([].concat(_toConsumableArray(Array.from(state.callRefsByResult.entries())), [[e, {
                __callId__: call.id,
                retain: call.retain
              }]]))
            };
          });
          if (call.interceptable && e !== alreadyCompletedException) {
            throw IGNORED_EXCEPTION;
          }
          _this4.setState(call.storyId, {
            forwardedException: e
          });
          return e;
        }
        throw e;
      };
      try {
        if (forwardedException) {
          this.setState(call.storyId, {
            forwardedException: void 0
          });
          throw forwardedException;
        }
        if (renderPhase === "played" && !call.retain) {
          throw alreadyCompletedException;
        }
        var finalArgs = options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args;
        var result = fn2.apply(void 0, _toConsumableArray(finalArgs.map(function(arg) {
          if (typeof arg !== "function" || Object.keys(arg).length)
            return arg;
          return function() {
            var _this4$getState = _this4.getState(call.storyId), cursor = _this4$getState.cursor, parentId = _this4$getState.parentId;
            _this4.setState(call.storyId, {
              cursor: 0,
              parentId: call.id
            });
            var restore = function restore2() {
              return _this4.setState(call.storyId, {
                cursor,
                parentId
              });
            };
            var res = arg.apply(void 0, arguments);
            if (res instanceof Promise)
              res.then(restore, restore);
            else
              restore();
            return res;
          };
        })));
        if (result && ["object", "function", "symbol"].includes(_typeof(result))) {
          this.setState(call.storyId, function(state) {
            return {
              callRefsByResult: new Map([].concat(_toConsumableArray(Array.from(state.callRefsByResult.entries())), [[result, {
                __callId__: call.id,
                retain: call.retain
              }]]))
            };
          });
        }
        this.update(Object.assign({}, info, {
          status: result instanceof Promise ? CallStates.ACTIVE : CallStates.DONE
        }));
        if (result instanceof Promise) {
          return result.then(function(value) {
            _this4.update(Object.assign({}, info, {
              status: CallStates.DONE
            }));
            return value;
          }, handleException);
        }
        return result;
      } catch (e) {
        return handleException(e);
      }
    }
  }, {
    key: "update",
    value: function update(call) {
      var _this5 = this;
      clearTimeout(this.getState(call.storyId).syncTimeout);
      this.channel.emit(EVENTS.CALL, call);
      this.setState(call.storyId, function(_ref19) {
        var calls = _ref19.calls;
        var callsById = calls.concat(call).reduce(function(a, c) {
          return Object.assign(a, _defineProperty({}, c.id, c));
        }, {});
        return {
          calls: Object.values(callsById).sort(function(a, b) {
            return a.id.localeCompare(b.id, void 0, {
              numeric: true
            });
          }),
          syncTimeout: setTimeout(function() {
            return _this5.sync(call.storyId);
          }, 0)
        };
      });
    }
  }, {
    key: "sync",
    value: function sync(storyId) {
      var _this$getState9 = this.getState(storyId), isLocked = _this$getState9.isLocked, isPlaying = _this$getState9.isPlaying;
      var logItems = this.getLog(storyId);
      var hasActive = logItems.some(function(item) {
        return item.status === CallStates.ACTIVE;
      });
      if (debuggerDisabled || isLocked || hasActive || logItems.length === 0) {
        this.channel.emit(EVENTS.SYNC, {
          controlStates: controlsDisabled,
          logItems
        });
        return;
      }
      var hasPrevious = logItems.some(function(item) {
        return [CallStates.DONE, CallStates.ERROR].includes(item.status);
      });
      var controlStates = {
        debugger: true,
        start: hasPrevious,
        back: hasPrevious,
        goto: true,
        next: isPlaying,
        end: isPlaying
      };
      this.channel.emit(EVENTS.SYNC, {
        controlStates,
        logItems
      });
    }
  }]);
  return Instrumenter2;
}();
function instrument(obj) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  try {
    var _global$window$locati, _global$window$locati2, _global$window$locati3, _global$window$locati4;
    var forceInstrument = false;
    var skipInstrument = false;
    if (((_global$window$locati = import_global.default.window.location) === null || _global$window$locati === void 0 ? void 0 : (_global$window$locati2 = _global$window$locati.search) === null || _global$window$locati2 === void 0 ? void 0 : _global$window$locati2.indexOf("instrument=true")) !== -1) {
      forceInstrument = true;
    } else if (((_global$window$locati3 = import_global.default.window.location) === null || _global$window$locati3 === void 0 ? void 0 : (_global$window$locati4 = _global$window$locati3.search) === null || _global$window$locati4 === void 0 ? void 0 : _global$window$locati4.indexOf("instrument=false")) !== -1) {
      skipInstrument = true;
    }
    if (import_global.default.window.parent === import_global.default.window && !forceInstrument || skipInstrument) {
      return obj;
    }
    if (!import_global.default.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__) {
      import_global.default.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter();
    }
    var instrumenter = import_global.default.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__;
    return instrumenter.instrument(obj, options);
  } catch (e) {
    once.warn(e);
    return obj;
  }
}

// ../../node_modules/@storybook/addon-interactions/dist/esm/preset/preview.js
var import_jest_mock = __toESM(require_build());
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
var JestMock = new import_jest_mock.ModuleMocker(global);
var fn = JestMock.fn.bind(JestMock);
var _instrument = instrument({
  action: fn
}, {
  retain: true
});
var action = _instrument.action;
var channel = addons.getChannel();
var spies = [];
channel.on(FORCE_REMOUNT, function() {
  return spies.forEach(function(mock) {
    var _mock$mockClear;
    return mock === null || mock === void 0 ? void 0 : (_mock$mockClear = mock.mockClear) === null || _mock$mockClear === void 0 ? void 0 : _mock$mockClear.call(mock);
  });
});
channel.on(STORY_RENDER_PHASE_CHANGED, function(_ref) {
  var newPhase = _ref.newPhase;
  if (newPhase === "loading")
    spies.forEach(function(mock) {
      var _mock$mockClear2;
      return mock === null || mock === void 0 ? void 0 : (_mock$mockClear2 = mock.mockClear) === null || _mock$mockClear2 === void 0 ? void 0 : _mock$mockClear2.call(mock);
    });
});
var addActionsFromArgTypes = function addActionsFromArgTypes2(_ref2) {
  var id = _ref2.id, initialArgs = _ref2.initialArgs;
  return Object.entries(initialArgs).reduce(function(acc, _ref3) {
    var _ref4 = _slicedToArray2(_ref3, 2), key = _ref4[0], val = _ref4[1];
    if (typeof val === "function" && val.name === "actionHandler") {
      Object.defineProperty(val, "name", {
        value: key,
        writable: false
      });
      Object.defineProperty(val, "__storyId__", {
        value: id,
        writable: false
      });
      acc[key] = action(val);
      spies.push(acc[key]);
      return acc;
    }
    acc[key] = val;
    return acc;
  }, {});
};
var argsEnhancers = [addActionsFromArgTypes];
export {
  argsEnhancers
};
//# sourceMappingURL=@storybook_addon-interactions_preview__js.js.map

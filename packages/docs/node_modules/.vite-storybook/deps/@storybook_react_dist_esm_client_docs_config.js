import {
  require_react_is
} from "./chunk-PQRL4ZDL.js";
import {
  require_prop_types
} from "./chunk-ISDLMTRE.js";
import {
  require_isString
} from "./chunk-3XHL36QC.js";
import {
  require_html_tags
} from "./chunk-ZJFNCWNI.js";
import {
  require_escodegen
} from "./chunk-O2WKRP6T.js";
import "./chunk-CAUQYPC3.js";
import {
  ancestor,
  base,
  simple
} from "./chunk-TEX7ADST.js";
import {
  require_dist
} from "./chunk-ZYJIHTF4.js";
import {
  require_acorn_jsx
} from "./chunk-A3DAW476.js";
import {
  Parser,
  init_acorn
} from "./chunk-UQ2RLNFR.js";
import {
  SNIPPET_RENDERED,
  SourceType,
  TypeSystem,
  createSummaryValue,
  enhanceArgTypes,
  extractComponentDescription,
  extractComponentProps,
  getDocgenSection,
  hasDocgen,
  isTooLongForDefaultValueSummary,
  isTooLongForTypeSummary
} from "./chunk-YRY53SRV.js";
import "./chunk-XEMLCLBP.js";
import "./chunk-4VTP7LPX.js";
import "./chunk-2QINEMXG.js";
import "./chunk-CPSLMASQ.js";
import "./chunk-BKLCY3MB.js";
import "./chunk-4GJJ3266.js";
import {
  require_react
} from "./chunk-YP55OVAM.js";
import "./chunk-KO7A3BOR.js";
import "./chunk-6AMIYDZK.js";
import "./chunk-JKQEB2HT.js";
import "./chunk-2BNDCU4E.js";
import "./chunk-RVLC2H4V.js";
import "./chunk-JT32EAWO.js";
import "./chunk-TC2YVOMY.js";
import "./chunk-GBUQ54EE.js";
import "./chunk-P6DH35JE.js";
import "./chunk-2S47NWC5.js";
import "./chunk-D7ACLUDI.js";
import "./chunk-3QAHKC62.js";
import "./chunk-2QTPEREA.js";
import "./chunk-VIPQIB44.js";
import "./chunk-6SPLJA5R.js";
import {
  require_isPlainObject
} from "./chunk-NIJPRW6G.js";
import "./chunk-LVEI5CBR.js";
import "./chunk-4AVEF3UG.js";
import "./chunk-HKTZX4RO.js";
import "./chunk-V7WRJ3OC.js";
import "./chunk-TUXWE5E7.js";
import "./chunk-SRJBFAHE.js";
import "./chunk-BY3TF4HS.js";
import "./chunk-E3JZOUSM.js";
import "./chunk-PXJ2EFCI.js";
import "./chunk-UMWVCJJW.js";
import "./chunk-3TPYYIGO.js";
import "./chunk-VK73QKD6.js";
import "./chunk-MKPOCVZZ.js";
import "./chunk-63SA34OX.js";
import "./chunk-ZYKZK7DK.js";
import "./chunk-G4G225G7.js";
import "./chunk-KVJKXG33.js";
import "./chunk-WSDZJAUT.js";
import "./chunk-DNEXKNCO.js";
import "./chunk-HSGGWLNP.js";
import {
  addons,
  useEffect
} from "./chunk-KYT6TJGM.js";
import "./chunk-7DN4YUXE.js";
import "./chunk-YVEEV5MS.js";
import "./chunk-66X6BCQU.js";
import "./chunk-CKIBD2RD.js";
import "./chunk-PXKLPDSH.js";
import "./chunk-AESLGWHI.js";
import "./chunk-PTJ6TCCX.js";
import "./chunk-627YFXPD.js";
import "./chunk-L3SKGDWI.js";
import "./chunk-XJ2JJV6N.js";
import "./chunk-LMMZB5YI.js";
import "./chunk-XDPD5MQI.js";
import "./chunk-B34QWUD7.js";
import "./chunk-NQXOWTFC.js";
import "./chunk-DPP4NJUX.js";
import "./chunk-DCMIIV5R.js";
import "./chunk-CNWJLUKC.js";
import "./chunk-3KZXGAFX.js";
import "./chunk-RNM52WSY.js";
import {
  require_isFunction
} from "./chunk-A6ZGP4BD.js";
import "./chunk-KXDXTYII.js";
import "./chunk-AJSSKUKK.js";
import "./chunk-PFA5ARSF.js";
import "./chunk-E6FELHDU.js";
import "./chunk-U7UCLSQI.js";
import "./chunk-NIAN2TDC.js";
import "./chunk-NEK5IPCF.js";
import "./chunk-WRNXHNZR.js";
import {
  esm_default
} from "./chunk-63CEWH4T.js";
import {
  require_browser
} from "./chunk-EU3NVPBZ.js";
import {
  logger,
  require_es_regexp_exec
} from "./chunk-5CNPPXEO.js";
import {
  require_es_array_iterator,
  require_es_string_iterator
} from "./chunk-5JKXEZBY.js";
import "./chunk-D2M6HF7H.js";
import "./chunk-IPOUH34V.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// ../../node_modules/@storybook/react/dist/esm/client/docs/extractProps.js
var import_es_array_iterator2 = __toESM(require_es_array_iterator());
var import_es_string_iterator2 = __toESM(require_es_string_iterator());
var import_prop_types = __toESM(require_prop_types());

// ../../node_modules/@storybook/react/dist/esm/client/docs/propTypes/createType.js
var import_es_regexp_exec3 = __toESM(require_es_regexp_exec());

// ../../node_modules/@storybook/react/dist/esm/client/docs/propTypes/generateFuncSignature.js
var import_es_regexp_exec = __toESM(require_es_regexp_exec());
function generateFuncSignature(params, returns) {
  var hasParams = params != null;
  var hasReturns = returns != null;
  if (!hasParams && !hasReturns) {
    return "";
  }
  var funcParts = [];
  if (hasParams) {
    var funcParams = params.map(function(x) {
      var prettyName = x.getPrettyName();
      var typeName = x.getTypeName();
      if (typeName != null) {
        return "".concat(prettyName, ": ").concat(typeName);
      }
      return prettyName;
    });
    funcParts.push("(".concat(funcParams.join(", "), ")"));
  } else {
    funcParts.push("()");
  }
  if (hasReturns) {
    funcParts.push("=> ".concat(returns.getTypeName()));
  }
  return funcParts.join(" ");
}
function generateShortFuncSignature(params, returns) {
  var hasParams = params != null;
  var hasReturns = returns != null;
  if (!hasParams && !hasReturns) {
    return "";
  }
  var funcParts = [];
  if (hasParams) {
    funcParts.push("( ... )");
  } else {
    funcParts.push("()");
  }
  if (hasReturns) {
    funcParts.push("=> ".concat(returns.getTypeName()));
  }
  return funcParts.join(" ");
}
function toMultilineSignature(signature) {
  return signature.replace(/,/g, ",\r\n");
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/captions.js
var CUSTOM_CAPTION = "custom";
var OBJECT_CAPTION = "object";
var ARRAY_CAPTION = "array";
var CLASS_CAPTION = "class";
var FUNCTION_CAPTION = "func";
var ELEMENT_CAPTION = "element";

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/isHtmlTag.js
var import_html_tags = __toESM(require_html_tags());
function isHtmlTag(tagName) {
  return import_html_tags.default.includes(tagName.toLowerCase());
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/generateCode.js
var import_es_regexp_exec2 = __toESM(require_es_regexp_exec());
var import_escodegen = __toESM(require_escodegen());
var BASIC_OPTIONS = {
  format: {
    indent: {
      style: "  "
    },
    semicolons: false
  }
};
var COMPACT_OPTIONS = Object.assign({}, BASIC_OPTIONS, {
  format: {
    newline: ""
  }
});
var PRETTY_OPTIONS = Object.assign({}, BASIC_OPTIONS);
function generateCode(ast) {
  var compact = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return (0, import_escodegen.generate)(ast, compact ? COMPACT_OPTIONS : PRETTY_OPTIONS);
}
function generateObjectCode(ast) {
  var compact = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return !compact ? generateCode(ast) : generateCompactObjectCode(ast);
}
function generateCompactObjectCode(ast) {
  var result = generateCode(ast, true);
  if (!result.endsWith(" }")) {
    result = "".concat(result.slice(0, -1), " }");
  }
  return result;
}
function generateArrayCode(ast) {
  var compact = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return !compact ? generateMultilineArrayCode(ast) : generateCompactArrayCode(ast);
}
function generateMultilineArrayCode(ast) {
  var result = generateCode(ast);
  if (result.endsWith("  }]")) {
    result = esm_default(result);
  }
  return result;
}
function generateCompactArrayCode(ast) {
  var result = generateCode(ast, true);
  if (result.startsWith("[    ")) {
    result = result.replace("[    ", "[");
  }
  return result;
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/componentTypes.js
var isMemo = function isMemo2(component) {
  return component.$$typeof === Symbol.for("react.memo");
};
var isForwardRef = function isForwardRef2(component) {
  return component.$$typeof === Symbol.for("react.forward_ref");
};

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/inspection/types.js
var InspectionType;
(function(InspectionType2) {
  InspectionType2["IDENTIFIER"] = "Identifier";
  InspectionType2["LITERAL"] = "Literal";
  InspectionType2["OBJECT"] = "Object";
  InspectionType2["ARRAY"] = "Array";
  InspectionType2["FUNCTION"] = "Function";
  InspectionType2["CLASS"] = "Class";
  InspectionType2["ELEMENT"] = "Element";
  InspectionType2["UNKNOWN"] = "Unknown";
})(InspectionType || (InspectionType = {}));

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/inspection/acornParser.js
init_acorn();
var import_acorn_jsx = __toESM(require_acorn_jsx());
var ACORN_WALK_VISITORS = Object.assign({}, base, {
  JSXElement: function JSXElement() {
  }
});
var acornParser = Parser.extend((0, import_acorn_jsx.default)());
function extractIdentifierName(identifierNode) {
  return identifierNode != null ? identifierNode.name : null;
}
function filterAncestors(ancestors) {
  return ancestors.filter(function(x) {
    return x.type === "ObjectExpression" || x.type === "ArrayExpression";
  });
}
function calculateNodeDepth(node) {
  var depths = [];
  ancestor(
    node,
    {
      ObjectExpression: function ObjectExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      },
      ArrayExpression: function ArrayExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      }
    },
    ACORN_WALK_VISITORS
  );
  return Math.max.apply(Math, depths);
}
function parseIdentifier(identifierNode) {
  return {
    inferredType: {
      type: InspectionType.IDENTIFIER,
      identifier: extractIdentifierName(identifierNode)
    },
    ast: identifierNode
  };
}
function parseLiteral(literalNode) {
  return {
    inferredType: {
      type: InspectionType.LITERAL
    },
    ast: literalNode
  };
}
function parseFunction(funcNode) {
  var innerJsxElementNode;
  simple(
    funcNode.body,
    {
      JSXElement: function JSXElement2(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  );
  var isJsx = innerJsxElementNode != null;
  var inferredType = {
    type: isJsx ? InspectionType.ELEMENT : InspectionType.FUNCTION,
    params: funcNode.params,
    hasParams: funcNode.params.length !== 0
  };
  var identifierName = extractIdentifierName(funcNode.id);
  if (identifierName != null) {
    inferredType.identifier = identifierName;
  }
  return {
    inferredType,
    ast: funcNode
  };
}
function parseClass(classNode) {
  var innerJsxElementNode;
  simple(
    classNode.body,
    {
      JSXElement: function JSXElement2(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  );
  var inferredType = {
    type: innerJsxElementNode != null ? InspectionType.ELEMENT : InspectionType.CLASS,
    identifier: extractIdentifierName(classNode.id)
  };
  return {
    inferredType,
    ast: classNode
  };
}
function parseJsxElement(jsxElementNode) {
  var inferredType = {
    type: InspectionType.ELEMENT
  };
  var identifierName = extractIdentifierName(jsxElementNode.openingElement.name);
  if (identifierName != null) {
    inferredType.identifier = identifierName;
  }
  return {
    inferredType,
    ast: jsxElementNode
  };
}
function parseCall(callNode) {
  var identifierNode = callNode.callee.type === "MemberExpression" ? callNode.callee.property : callNode.callee;
  var identifierName = extractIdentifierName(identifierNode);
  if (identifierName === "shape") {
    return parseObject(callNode.arguments[0]);
  }
  return null;
}
function parseObject(objectNode) {
  return {
    inferredType: {
      type: InspectionType.OBJECT,
      depth: calculateNodeDepth(objectNode)
    },
    ast: objectNode
  };
}
function parseArray(arrayNode) {
  return {
    inferredType: {
      type: InspectionType.ARRAY,
      depth: calculateNodeDepth(arrayNode)
    },
    ast: arrayNode
  };
}
function parseExpression(expression) {
  switch (expression.type) {
    case "Identifier":
      return parseIdentifier(expression);
    case "Literal":
      return parseLiteral(expression);
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return parseFunction(expression);
    case "ClassExpression":
      return parseClass(expression);
    case "JSXElement":
      return parseJsxElement(expression);
    case "CallExpression":
      return parseCall(expression);
    case "ObjectExpression":
      return parseObject(expression);
    case "ArrayExpression":
      return parseArray(expression);
    default:
      return null;
  }
}
function parse(value) {
  var ast = acornParser.parse("(".concat(value, ")"));
  var parsingResult = {
    inferredType: {
      type: InspectionType.UNKNOWN
    },
    ast
  };
  if (ast.body[0] != null) {
    var rootNode = ast.body[0];
    switch (rootNode.type) {
      case "ExpressionStatement": {
        var expressionResult = parseExpression(rootNode.expression);
        if (expressionResult != null) {
          parsingResult = expressionResult;
        }
        break;
      }
      default:
        break;
    }
  }
  return parsingResult;
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/inspection/inspectValue.js
function inspectValue(value) {
  try {
    var parsingResult = parse(value);
    return Object.assign({}, parsingResult);
  } catch (e) {
  }
  return {
    inferredType: {
      type: InspectionType.UNKNOWN
    }
  };
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/propTypes/createType.js
var MAX_FUNC_LENGTH = 150;
var PropTypesType;
(function(PropTypesType2) {
  PropTypesType2["CUSTOM"] = "custom";
  PropTypesType2["ANY"] = "any";
  PropTypesType2["FUNC"] = "func";
  PropTypesType2["SHAPE"] = "shape";
  PropTypesType2["OBJECT"] = "object";
  PropTypesType2["INSTANCEOF"] = "instanceOf";
  PropTypesType2["OBJECTOF"] = "objectOf";
  PropTypesType2["UNION"] = "union";
  PropTypesType2["ENUM"] = "enum";
  PropTypesType2["ARRAYOF"] = "arrayOf";
  PropTypesType2["ELEMENT"] = "element";
  PropTypesType2["ELEMENTTYPE"] = "elementType";
  PropTypesType2["NODE"] = "node";
})(PropTypesType || (PropTypesType = {}));
function createTypeDef(_ref) {
  var name = _ref.name, short = _ref.short, compact = _ref.compact, full = _ref.full, inferredType = _ref.inferredType;
  return {
    name,
    short,
    compact,
    full: full != null ? full : short,
    inferredType
  };
}
function cleanPropTypes(value) {
  return value.replace(/PropTypes./g, "").replace(/.isRequired/g, "");
}
function splitIntoLines(value) {
  return value.split(/\r?\n/);
}
function prettyObject(ast) {
  var compact = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return cleanPropTypes(generateObjectCode(ast, compact));
}
function prettyArray(ast) {
  var compact = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return cleanPropTypes(generateCode(ast, compact));
}
function getCaptionForInspectionType(type) {
  switch (type) {
    case InspectionType.OBJECT:
      return OBJECT_CAPTION;
    case InspectionType.ARRAY:
      return ARRAY_CAPTION;
    case InspectionType.CLASS:
      return CLASS_CAPTION;
    case InspectionType.FUNCTION:
      return FUNCTION_CAPTION;
    case InspectionType.ELEMENT:
      return ELEMENT_CAPTION;
    default:
      return CUSTOM_CAPTION;
  }
}
function generateTypeFromString(value, originalTypeName) {
  var _inspectValue = inspectValue(value), inferredType = _inspectValue.inferredType, ast = _inspectValue.ast;
  var type = inferredType.type;
  var short;
  var compact;
  var full;
  switch (type) {
    case InspectionType.IDENTIFIER:
    case InspectionType.LITERAL:
      short = value;
      compact = value;
      break;
    case InspectionType.OBJECT: {
      var _ref2 = inferredType, depth = _ref2.depth;
      short = OBJECT_CAPTION;
      compact = depth === 1 ? prettyObject(ast, true) : null;
      full = prettyObject(ast);
      break;
    }
    case InspectionType.ELEMENT: {
      var _ref3 = inferredType, identifier = _ref3.identifier;
      short = identifier != null && !isHtmlTag(identifier) ? identifier : ELEMENT_CAPTION;
      compact = splitIntoLines(value).length === 1 ? value : null;
      full = value;
      break;
    }
    case InspectionType.ARRAY: {
      var _ref4 = inferredType, _depth = _ref4.depth;
      short = ARRAY_CAPTION;
      compact = _depth <= 2 ? prettyArray(ast, true) : null;
      full = prettyArray(ast);
      break;
    }
    default:
      short = getCaptionForInspectionType(type);
      compact = splitIntoLines(value).length === 1 ? value : null;
      full = value;
      break;
  }
  return createTypeDef({
    name: originalTypeName,
    short,
    compact,
    full,
    inferredType: type
  });
}
function generateCustom(_ref5) {
  var raw = _ref5.raw;
  if (raw != null) {
    return generateTypeFromString(raw, PropTypesType.CUSTOM);
  }
  return createTypeDef({
    name: PropTypesType.CUSTOM,
    short: CUSTOM_CAPTION,
    compact: CUSTOM_CAPTION
  });
}
function generateFunc(extractedProp) {
  var jsDocTags = extractedProp.jsDocTags;
  if (jsDocTags != null) {
    if (jsDocTags.params != null || jsDocTags.returns != null) {
      return createTypeDef({
        name: PropTypesType.FUNC,
        short: generateShortFuncSignature(jsDocTags.params, jsDocTags.returns),
        compact: null,
        full: generateFuncSignature(jsDocTags.params, jsDocTags.returns)
      });
    }
  }
  return createTypeDef({
    name: PropTypesType.FUNC,
    short: FUNCTION_CAPTION,
    compact: FUNCTION_CAPTION
  });
}
function generateShape(type, extractedProp) {
  var fields = Object.keys(type.value).map(function(key) {
    return "".concat(key, ": ").concat(generateType(type.value[key], extractedProp).full);
  }).join(", ");
  var _inspectValue2 = inspectValue("{ ".concat(fields, " }")), inferredType = _inspectValue2.inferredType, ast = _inspectValue2.ast;
  var _ref6 = inferredType, depth = _ref6.depth;
  return createTypeDef({
    name: PropTypesType.SHAPE,
    short: OBJECT_CAPTION,
    compact: depth === 1 && ast ? prettyObject(ast, true) : null,
    full: ast ? prettyObject(ast) : null
  });
}
function objectOf(of) {
  return "objectOf(".concat(of, ")");
}
function generateObjectOf(type, extractedProp) {
  var _generateType = generateType(type.value, extractedProp), short = _generateType.short, compact = _generateType.compact, full = _generateType.full;
  return createTypeDef({
    name: PropTypesType.OBJECTOF,
    short: objectOf(short),
    compact: compact != null ? objectOf(compact) : null,
    full: objectOf(full)
  });
}
function generateUnion(type, extractedProp) {
  if (Array.isArray(type.value)) {
    var values = type.value.reduce(function(acc, v) {
      var _generateType2 = generateType(v, extractedProp), short = _generateType2.short, compact = _generateType2.compact, full = _generateType2.full;
      acc.short.push(short);
      acc.compact.push(compact);
      acc.full.push(full);
      return acc;
    }, {
      short: [],
      compact: [],
      full: []
    });
    return createTypeDef({
      name: PropTypesType.UNION,
      short: values.short.join(" | "),
      compact: values.compact.every(function(x) {
        return x != null;
      }) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({
    name: PropTypesType.UNION,
    short: type.value,
    compact: null
  });
}
function generateEnumValue(_ref7) {
  var value = _ref7.value, computed = _ref7.computed;
  return computed ? generateTypeFromString(value, "enumvalue") : createTypeDef({
    name: "enumvalue",
    short: value,
    compact: value
  });
}
function generateEnum(type) {
  if (Array.isArray(type.value)) {
    var values = type.value.reduce(function(acc, v) {
      var _generateEnumValue = generateEnumValue(v), short = _generateEnumValue.short, compact = _generateEnumValue.compact, full = _generateEnumValue.full;
      acc.short.push(short);
      acc.compact.push(compact);
      acc.full.push(full);
      return acc;
    }, {
      short: [],
      compact: [],
      full: []
    });
    return createTypeDef({
      name: PropTypesType.ENUM,
      short: values.short.join(" | "),
      compact: values.compact.every(function(x) {
        return x != null;
      }) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({
    name: PropTypesType.ENUM,
    short: type.value,
    compact: type.value
  });
}
function braceAfter(of) {
  return "".concat(of, "[]");
}
function braceAround(of) {
  return "[".concat(of, "]");
}
function createArrayOfObjectTypeDef(short, compact, full) {
  return createTypeDef({
    name: PropTypesType.ARRAYOF,
    short: braceAfter(short),
    compact: compact != null ? braceAround(compact) : null,
    full: braceAround(full)
  });
}
function generateArray(type, extractedProp) {
  var _generateType3 = generateType(type.value, extractedProp), name = _generateType3.name, short = _generateType3.short, compact = _generateType3.compact, full = _generateType3.full, inferredType = _generateType3.inferredType;
  if (name === PropTypesType.CUSTOM) {
    if (inferredType === InspectionType.OBJECT) {
      return createArrayOfObjectTypeDef(short, compact, full);
    }
  } else if (name === PropTypesType.SHAPE) {
    return createArrayOfObjectTypeDef(short, compact, full);
  }
  return createTypeDef({
    name: PropTypesType.ARRAYOF,
    short: braceAfter(short),
    compact: braceAfter(short)
  });
}
function generateType(type, extractedProp) {
  try {
    switch (type.name) {
      case PropTypesType.CUSTOM:
        return generateCustom(type);
      case PropTypesType.FUNC:
        return generateFunc(extractedProp);
      case PropTypesType.SHAPE:
        return generateShape(type, extractedProp);
      case PropTypesType.INSTANCEOF:
        return createTypeDef({
          name: PropTypesType.INSTANCEOF,
          short: type.value,
          compact: type.value
        });
      case PropTypesType.OBJECTOF:
        return generateObjectOf(type, extractedProp);
      case PropTypesType.UNION:
        return generateUnion(type, extractedProp);
      case PropTypesType.ENUM:
        return generateEnum(type);
      case PropTypesType.ARRAYOF:
        return generateArray(type, extractedProp);
      default:
        return createTypeDef({
          name: type.name,
          short: type.name,
          compact: type.name
        });
    }
  } catch (e) {
    console.error(e);
  }
  return createTypeDef({
    name: "unknown",
    short: "unknown",
    compact: "unknown"
  });
}
function createType(extractedProp) {
  var type = extractedProp.docgenInfo.type;
  if (type == null) {
    return null;
  }
  try {
    switch (type.name) {
      case PropTypesType.CUSTOM:
      case PropTypesType.SHAPE:
      case PropTypesType.INSTANCEOF:
      case PropTypesType.OBJECTOF:
      case PropTypesType.UNION:
      case PropTypesType.ENUM:
      case PropTypesType.ARRAYOF: {
        var _generateType4 = generateType(type, extractedProp), short = _generateType4.short, compact = _generateType4.compact, full = _generateType4.full;
        if (compact != null) {
          if (!isTooLongForTypeSummary(compact)) {
            return createSummaryValue(compact);
          }
        }
        return createSummaryValue(short, full);
      }
      case PropTypesType.FUNC: {
        var _generateType5 = generateType(type, extractedProp), _short = _generateType5.short, _full = _generateType5.full;
        var summary = _short;
        var detail;
        if (_full.length < MAX_FUNC_LENGTH) {
          summary = _full;
        } else {
          detail = toMultilineSignature(_full);
        }
        return createSummaryValue(summary, detail);
      }
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/defaultValues/generateObject.js
function generateObject(_ref) {
  var inferredType = _ref.inferredType, ast = _ref.ast;
  var _ref2 = inferredType, depth = _ref2.depth;
  if (depth === 1) {
    var compactObject = generateObjectCode(ast, true);
    if (!isTooLongForDefaultValueSummary(compactObject)) {
      return createSummaryValue(compactObject);
    }
  }
  return createSummaryValue(OBJECT_CAPTION, generateObjectCode(ast));
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/defaultValues/generateArray.js
function generateArray2(_ref) {
  var inferredType = _ref.inferredType, ast = _ref.ast;
  var _ref2 = inferredType, depth = _ref2.depth;
  if (depth <= 2) {
    var compactArray = generateArrayCode(ast, true);
    if (!isTooLongForDefaultValueSummary(compactArray)) {
      return createSummaryValue(compactArray);
    }
  }
  return createSummaryValue(ARRAY_CAPTION, generateArrayCode(ast));
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/defaultValues/prettyIdentifier.js
function getPrettyIdentifier(inferredType) {
  var type = inferredType.type, identifier = inferredType.identifier;
  switch (type) {
    case InspectionType.FUNCTION:
      return getPrettyFuncIdentifier(identifier, inferredType.hasParams);
    case InspectionType.ELEMENT:
      return getPrettyElementIdentifier(identifier);
    default:
      return identifier;
  }
}
function getPrettyFuncIdentifier(identifier, hasArguments) {
  return hasArguments ? "".concat(identifier, "( ... )") : "".concat(identifier, "()");
}
function getPrettyElementIdentifier(identifier) {
  return "<".concat(identifier, " />");
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/defaultValues/createDefaultValue.js
function generateFunc2(_ref) {
  var inferredType = _ref.inferredType, ast = _ref.ast;
  var _ref2 = inferredType, identifier = _ref2.identifier;
  if (identifier != null) {
    return createSummaryValue(getPrettyIdentifier(inferredType), generateCode(ast));
  }
  var prettyCaption = generateCode(ast, true);
  return !isTooLongForDefaultValueSummary(prettyCaption) ? createSummaryValue(prettyCaption) : createSummaryValue(FUNCTION_CAPTION, generateCode(ast));
}
function generateElement(defaultValue, inspectionResult) {
  var inferredType = inspectionResult.inferredType;
  var _ref3 = inferredType, identifier = _ref3.identifier;
  if (identifier != null) {
    if (!isHtmlTag(identifier)) {
      var prettyIdentifier = getPrettyIdentifier(inferredType);
      return createSummaryValue(prettyIdentifier, defaultValue);
    }
  }
  return !isTooLongForDefaultValueSummary(defaultValue) ? createSummaryValue(defaultValue) : createSummaryValue(ELEMENT_CAPTION, defaultValue);
}
function createDefaultValue(defaultValue) {
  try {
    var inspectionResult = inspectValue(defaultValue);
    switch (inspectionResult.inferredType.type) {
      case InspectionType.OBJECT:
        return generateObject(inspectionResult);
      case InspectionType.FUNCTION:
        return generateFunc2(inspectionResult);
      case InspectionType.ELEMENT:
        return generateElement(defaultValue, inspectionResult);
      case InspectionType.ARRAY:
        return generateArray2(inspectionResult);
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/defaultValues/createFromRawDefaultProp.js
var import_es_regexp_exec4 = __toESM(require_es_regexp_exec());
var import_es_array_iterator = __toESM(require_es_array_iterator());
var import_es_string_iterator = __toESM(require_es_string_iterator());
var import_isPlainObject = __toESM(require_isPlainObject());
var import_isFunction = __toESM(require_isFunction());
var import_isString = __toESM(require_isString());

// ../../node_modules/react-element-to-jsx-string/node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// ../../node_modules/react-element-to-jsx-string/dist/esm/index.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var import_pretty_print_object = __toESM(require_dist());
var import_react_is = __toESM(require_react_is());
var spacer = function(times, tabStop) {
  if (times === 0) {
    return "";
  }
  return new Array(times * tabStop).fill(" ").join("");
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function safeSortObject(value, seen) {
  if (value === null || _typeof(value) !== "object") {
    return value;
  }
  if (value instanceof Date || value instanceof RegExp || React.isValidElement(value)) {
    return value;
  }
  seen.add(value);
  if (Array.isArray(value)) {
    return value.map(function(v) {
      return safeSortObject(v, seen);
    });
  }
  return Object.keys(value).sort().reduce(function(result, key) {
    if (key === "_owner") {
      return result;
    }
    if (key === "current" || seen.has(value[key])) {
      result[key] = "[Circular]";
    } else {
      result[key] = safeSortObject(value[key], seen);
    }
    return result;
  }, {});
}
function sortObject(value) {
  return safeSortObject(value, /* @__PURE__ */ new WeakSet());
}
var createStringTreeNode = function createStringTreeNode2(value) {
  return {
    type: "string",
    value
  };
};
var createNumberTreeNode = function createNumberTreeNode2(value) {
  return {
    type: "number",
    value
  };
};
var createReactElementTreeNode = function createReactElementTreeNode2(displayName, props, defaultProps, childrens) {
  return {
    type: "ReactElement",
    displayName,
    props,
    defaultProps,
    childrens
  };
};
var createReactFragmentTreeNode = function createReactFragmentTreeNode2(key, childrens) {
  return {
    type: "ReactFragment",
    key,
    childrens
  };
};
var supportFragment = Boolean(import_react.Fragment);
var getFunctionTypeName = function getFunctionTypeName2(functionType) {
  if (!functionType.name || functionType.name === "_default") {
    return "No Display Name";
  }
  return functionType.name;
};
var getWrappedComponentDisplayName = function getWrappedComponentDisplayName2(Component) {
  switch (true) {
    case Boolean(Component.displayName):
      return Component.displayName;
    case Component.$$typeof === import_react_is.Memo:
      return getWrappedComponentDisplayName2(Component.type);
    case Component.$$typeof === import_react_is.ForwardRef:
      return getWrappedComponentDisplayName2(Component.render);
    default:
      return getFunctionTypeName(Component);
  }
};
var getReactElementDisplayName = function getReactElementDisplayName2(element) {
  switch (true) {
    case typeof element.type === "string":
      return element.type;
    case typeof element.type === "function":
      if (element.type.displayName) {
        return element.type.displayName;
      }
      return getFunctionTypeName(element.type);
    case (0, import_react_is.isForwardRef)(element):
    case (0, import_react_is.isMemo)(element):
      return getWrappedComponentDisplayName(element.type);
    case (0, import_react_is.isContextConsumer)(element):
      return "".concat(element.type._context.displayName || "Context", ".Consumer");
    case (0, import_react_is.isContextProvider)(element):
      return "".concat(element.type._context.displayName || "Context", ".Provider");
    case (0, import_react_is.isLazy)(element):
      return "Lazy";
    case (0, import_react_is.isProfiler)(element):
      return "Profiler";
    case (0, import_react_is.isStrictMode)(element):
      return "StrictMode";
    case (0, import_react_is.isSuspense)(element):
      return "Suspense";
    default:
      return "UnknownElementType";
  }
};
var noChildren = function noChildren2(propsValue, propName) {
  return propName !== "children";
};
var onlyMeaningfulChildren = function onlyMeaningfulChildren2(children) {
  return children !== true && children !== false && children !== null && children !== "";
};
var filterProps = function filterProps2(originalProps, cb) {
  var filteredProps = {};
  Object.keys(originalProps).filter(function(key) {
    return cb(originalProps[key], key);
  }).forEach(function(key) {
    return filteredProps[key] = originalProps[key];
  });
  return filteredProps;
};
var parseReactElement = function parseReactElement2(element, options) {
  var _options$displayName = options.displayName, displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;
  if (typeof element === "string") {
    return createStringTreeNode(element);
  } else if (typeof element === "number") {
    return createNumberTreeNode(element);
  } else if (!import_react.default.isValidElement(element)) {
    throw new Error("react-element-to-jsx-string: Expected a React.Element, got `".concat(_typeof(element), "`"));
  }
  var displayName = displayNameFn(element);
  var props = filterProps(element.props, noChildren);
  if (element.ref !== null) {
    props.ref = element.ref;
  }
  var key = element.key;
  if (typeof key === "string" && key.search(/^\./)) {
    props.key = key;
  }
  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);
  var childrens = import_react.default.Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function(child) {
    return parseReactElement2(child, options);
  });
  if (supportFragment && element.type === import_react.Fragment) {
    return createReactFragmentTreeNode(key, childrens);
  }
  return createReactElementTreeNode(displayName, props, defaultProps, childrens);
};
function noRefCheck() {
}
var inlineFunction = function inlineFunction2(fn) {
  return fn.toString().split("\n").map(function(line) {
    return line.trim();
  }).join("");
};
var defaultFunctionValue = inlineFunction;
var formatFunction = function(fn, options) {
  var _options$functionValu = options.functionValue, functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu, showFunctions = options.showFunctions;
  if (!showFunctions && functionValue === defaultFunctionValue) {
    return functionValue(noRefCheck);
  }
  return functionValue(fn);
};
var formatComplexDataStructure = function(value, inline, lvl, options) {
  var normalizedValue = sortObject(value);
  var stringifiedValue = (0, import_pretty_print_object.prettyPrint)(normalizedValue, {
    transform: function transform(currentObj, prop, originalResult) {
      var currentValue = currentObj[prop];
      if (currentValue && (0, import_react.isValidElement)(currentValue)) {
        return formatTreeNode(parseReactElement(currentValue, options), true, lvl, options);
      }
      if (typeof currentValue === "function") {
        return formatFunction(currentValue, options);
      }
      return originalResult;
    }
  });
  if (inline) {
    return stringifiedValue.replace(/\s+/g, " ").replace(/{ /g, "{").replace(/ }/g, "}").replace(/\[ /g, "[").replace(/ ]/g, "]");
  }
  return stringifiedValue.replace(/\t/g, spacer(1, options.tabStop)).replace(/\n([^$])/g, "\n".concat(spacer(lvl + 1, options.tabStop), "$1"));
};
var escape$1 = function escape(s) {
  return s.replace(/"/g, "&quot;");
};
var formatPropValue = function formatPropValue2(propValue, inline, lvl, options) {
  if (typeof propValue === "number") {
    return "{".concat(String(propValue), "}");
  }
  if (typeof propValue === "string") {
    return '"'.concat(escape$1(propValue), '"');
  }
  if (_typeof(propValue) === "symbol") {
    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\((.*)\)/, "$1");
    if (!symbolDescription) {
      return "{Symbol()}";
    }
    return "{Symbol('".concat(symbolDescription, "')}");
  }
  if (typeof propValue === "function") {
    return "{".concat(formatFunction(propValue, options), "}");
  }
  if ((0, import_react.isValidElement)(propValue)) {
    return "{".concat(formatTreeNode(parseReactElement(propValue, options), true, lvl, options), "}");
  }
  if (propValue instanceof Date) {
    if (isNaN(propValue.valueOf())) {
      return "{new Date(NaN)}";
    }
    return '{new Date("'.concat(propValue.toISOString(), '")}');
  }
  if (isPlainObject(propValue) || Array.isArray(propValue)) {
    return "{".concat(formatComplexDataStructure(propValue, inline, lvl, options), "}");
  }
  return "{".concat(String(propValue), "}");
};
var formatProp = function(name, hasValue, value, hasDefaultValue, defaultValue, inline, lvl, options) {
  if (!hasValue && !hasDefaultValue) {
    throw new Error('The prop "'.concat(name, '" has no value and no default: could not be formatted'));
  }
  var usedValue = hasValue ? value : defaultValue;
  var useBooleanShorthandSyntax = options.useBooleanShorthandSyntax, tabStop = options.tabStop;
  var formattedPropValue = formatPropValue(usedValue, inline, lvl, options);
  var attributeFormattedInline = " ";
  var attributeFormattedMultiline = "\n".concat(spacer(lvl + 1, tabStop));
  var isMultilineAttribute = formattedPropValue.includes("\n");
  if (useBooleanShorthandSyntax && formattedPropValue === "{false}" && !hasDefaultValue) {
    attributeFormattedInline = "";
    attributeFormattedMultiline = "";
  } else if (useBooleanShorthandSyntax && formattedPropValue === "{true}") {
    attributeFormattedInline += "".concat(name);
    attributeFormattedMultiline += "".concat(name);
  } else {
    attributeFormattedInline += "".concat(name, "=").concat(formattedPropValue);
    attributeFormattedMultiline += "".concat(name, "=").concat(formattedPropValue);
  }
  return {
    attributeFormattedInline,
    attributeFormattedMultiline,
    isMultilineAttribute
  };
};
var mergeSiblingPlainStringChildrenReducer = function(previousNodes, currentNode) {
  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0);
  var previousNode = previousNodes[previousNodes.length - 1];
  if (previousNode && (currentNode.type === "string" || currentNode.type === "number") && (previousNode.type === "string" || previousNode.type === "number")) {
    nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value)));
  } else {
    if (previousNode) {
      nodes.push(previousNode);
    }
    nodes.push(currentNode);
  }
  return nodes;
};
var isKeyOrRefProps = function isKeyOrRefProps2(propName) {
  return ["key", "ref"].includes(propName);
};
var sortPropsByNames = function(shouldSortUserProps) {
  return function(props) {
    var haveKeyProp = props.includes("key");
    var haveRefProp = props.includes("ref");
    var userPropsOnly = props.filter(function(oneProp) {
      return !isKeyOrRefProps(oneProp);
    });
    var sortedProps = shouldSortUserProps ? _toConsumableArray(userPropsOnly.sort()) : _toConsumableArray(userPropsOnly);
    if (haveRefProp) {
      sortedProps.unshift("ref");
    }
    if (haveKeyProp) {
      sortedProps.unshift("key");
    }
    return sortedProps;
  };
};
function createPropFilter(props, filter) {
  if (Array.isArray(filter)) {
    return function(key) {
      return filter.indexOf(key) === -1;
    };
  } else {
    return function(key) {
      return filter(props[key], key);
    };
  }
}
var compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation2(element, formattedElement, inline, lvl, options) {
  var tabStop = options.tabStop;
  if (element.type === "string") {
    return formattedElement.split("\n").map(function(line, offset) {
      if (offset === 0) {
        return line;
      }
      return "".concat(spacer(lvl, tabStop)).concat(line);
    }).join("\n");
  }
  return formattedElement;
};
var formatOneChildren = function formatOneChildren2(inline, lvl, options) {
  return function(element) {
    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline, lvl, options), inline, lvl, options);
  };
};
var onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue2(defaultProps, props) {
  return function(propName) {
    var haveDefaultValue = Object.keys(defaultProps).includes(propName);
    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];
  };
};
var isInlineAttributeTooLong = function isInlineAttributeTooLong2(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {
  if (!maxInlineAttributesLineLength) {
    return attributes.length > 1;
  }
  return spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;
};
var shouldRenderMultilineAttr = function shouldRenderMultilineAttr2(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {
  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;
};
var formatReactElementNode = function(node, inline, lvl, options) {
  var type = node.type, _node$displayName = node.displayName, displayName = _node$displayName === void 0 ? "" : _node$displayName, childrens = node.childrens, _node$props = node.props, props = _node$props === void 0 ? {} : _node$props, _node$defaultProps = node.defaultProps, defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;
  if (type !== "ReactElement") {
    throw new Error('The "formatReactElementNode" function could only format node of type "ReactElement". Given:  '.concat(type));
  }
  var filterProps3 = options.filterProps, maxInlineAttributesLineLength = options.maxInlineAttributesLineLength, showDefaultProps = options.showDefaultProps, sortProps = options.sortProps, tabStop = options.tabStop;
  var out = "<".concat(displayName);
  var outInlineAttr = out;
  var outMultilineAttr = out;
  var containsMultilineAttr = false;
  var visibleAttributeNames = [];
  var propFilter = createPropFilter(props, filterProps3);
  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function(propName) {
    return visibleAttributeNames.push(propName);
  });
  Object.keys(defaultProps).filter(propFilter).filter(function() {
    return showDefaultProps;
  }).filter(function(defaultPropName) {
    return !visibleAttributeNames.includes(defaultPropName);
  }).forEach(function(defaultPropName) {
    return visibleAttributeNames.push(defaultPropName);
  });
  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);
  attributes.forEach(function(attributeName) {
    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options), attributeFormattedInline = _formatProp.attributeFormattedInline, attributeFormattedMultiline = _formatProp.attributeFormattedMultiline, isMultilineAttribute = _formatProp.isMultilineAttribute;
    if (isMultilineAttribute) {
      containsMultilineAttr = true;
    }
    outInlineAttr += attributeFormattedInline;
    outMultilineAttr += attributeFormattedMultiline;
  });
  outMultilineAttr += "\n".concat(spacer(lvl, tabStop));
  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {
    out = outMultilineAttr;
  } else {
    out = outInlineAttr;
  }
  if (childrens && childrens.length > 0) {
    var newLvl = lvl + 1;
    out += ">";
    if (!inline) {
      out += "\n";
      out += spacer(newLvl, tabStop);
    }
    out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? "\n".concat(spacer(newLvl, tabStop)) : "");
    if (!inline) {
      out += "\n";
      out += spacer(newLvl - 1, tabStop);
    }
    out += "</".concat(displayName, ">");
  } else {
    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {
      out += " ";
    }
    out += "/>";
  }
  return out;
};
var REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = "";
var REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = "React.Fragment";
var toReactElementTreeNode = function toReactElementTreeNode2(displayName, key, childrens) {
  var props = {};
  if (key) {
    props = {
      key
    };
  }
  return {
    type: "ReactElement",
    displayName,
    props,
    defaultProps: {},
    childrens
  };
};
var isKeyedFragment = function isKeyedFragment2(_ref) {
  var key = _ref.key;
  return Boolean(key);
};
var hasNoChildren = function hasNoChildren2(_ref2) {
  var childrens = _ref2.childrens;
  return childrens.length === 0;
};
var formatReactFragmentNode = function(node, inline, lvl, options) {
  var type = node.type, key = node.key, childrens = node.childrens;
  if (type !== "ReactFragment") {
    throw new Error('The "formatReactFragmentNode" function could only format node of type "ReactFragment". Given: '.concat(type));
  }
  var useFragmentShortSyntax = options.useFragmentShortSyntax;
  var displayName;
  if (useFragmentShortSyntax) {
    if (hasNoChildren(node) || isKeyedFragment(node)) {
      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;
    } else {
      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;
    }
  } else {
    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;
  }
  return formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline, lvl, options);
};
var jsxStopChars = ["<", ">", "{", "}"];
var shouldBeEscaped = function shouldBeEscaped2(s) {
  return jsxStopChars.some(function(jsxStopChar) {
    return s.includes(jsxStopChar);
  });
};
var escape2 = function escape3(s) {
  if (!shouldBeEscaped(s)) {
    return s;
  }
  return "{`".concat(s, "`}");
};
var preserveTrailingSpace = function preserveTrailingSpace2(s) {
  var result = s;
  if (result.endsWith(" ")) {
    result = result.replace(/^(.*?)(\s+)$/, "$1{'$2'}");
  }
  if (result.startsWith(" ")) {
    result = result.replace(/^(\s+)(.*)$/, "{'$1'}$2");
  }
  return result;
};
var formatTreeNode = function(node, inline, lvl, options) {
  if (node.type === "number") {
    return String(node.value);
  }
  if (node.type === "string") {
    return node.value ? "".concat(preserveTrailingSpace(escape2(String(node.value)))) : "";
  }
  if (node.type === "ReactElement") {
    return formatReactElementNode(node, inline, lvl, options);
  }
  if (node.type === "ReactFragment") {
    return formatReactFragmentNode(node, inline, lvl, options);
  }
  throw new TypeError('Unknow format type "'.concat(node.type, '"'));
};
var formatTree = function(node, options) {
  return formatTreeNode(node, false, 0, options);
};
var reactElementToJsxString = function reactElementToJsxString2(element) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$filterProps = _ref.filterProps, filterProps3 = _ref$filterProps === void 0 ? [] : _ref$filterProps, _ref$showDefaultProps = _ref.showDefaultProps, showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps, _ref$showFunctions = _ref.showFunctions, showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions, functionValue = _ref.functionValue, _ref$tabStop = _ref.tabStop, tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop, _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax, useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth, _ref$useFragmentShort = _ref.useFragmentShortSyntax, useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort, _ref$sortProps = _ref.sortProps, sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps, maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength, displayName = _ref.displayName;
  if (!element) {
    throw new Error("react-element-to-jsx-string: Expected a ReactElement");
  }
  var options = {
    filterProps: filterProps3,
    showDefaultProps,
    showFunctions,
    functionValue,
    tabStop,
    useBooleanShorthandSyntax,
    useFragmentShortSyntax,
    sortProps,
    maxInlineAttributesLineLength,
    displayName
  };
  return formatTree(parseReactElement(element, options), options);
};

// ../../node_modules/@storybook/react/dist/esm/client/docs/lib/defaultValues/createFromRawDefaultProp.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function isReactElement(element) {
  return element.$$typeof != null;
}
function extractFunctionName(func, propName) {
  var name = func.name;
  if (name !== "" && name !== "anonymous" && name !== propName) {
    return name;
  }
  return null;
}
var stringResolver = function stringResolver2(rawDefaultProp) {
  return createSummaryValue(JSON.stringify(rawDefaultProp));
};
function generateReactObject(rawDefaultProp) {
  var type = rawDefaultProp.type;
  var displayName = type.displayName;
  var jsx2 = reactElementToJsxString(rawDefaultProp, {});
  if (displayName != null) {
    var prettyIdentifier = getPrettyElementIdentifier(displayName);
    return createSummaryValue(prettyIdentifier, jsx2);
  }
  if ((0, import_isString.default)(type)) {
    if (isHtmlTag(type)) {
      var jsxCompact = reactElementToJsxString(rawDefaultProp, {
        tabStop: 0
      });
      var jsxSummary = jsxCompact.replace(/\r?\n|\r/g, "");
      if (!isTooLongForDefaultValueSummary(jsxSummary)) {
        return createSummaryValue(jsxSummary);
      }
    }
  }
  return createSummaryValue(ELEMENT_CAPTION, jsx2);
}
var objectResolver = function objectResolver2(rawDefaultProp) {
  if (isReactElement(rawDefaultProp) && rawDefaultProp.type != null) {
    return generateReactObject(rawDefaultProp);
  }
  if ((0, import_isPlainObject.default)(rawDefaultProp)) {
    var inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateObject(inspectionResult);
  }
  if (Array.isArray(rawDefaultProp)) {
    var _inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateArray2(_inspectionResult);
  }
  return createSummaryValue(OBJECT_CAPTION);
};
var functionResolver = function functionResolver2(rawDefaultProp, propDef) {
  var isElement = false;
  var inspectionResult;
  if ((0, import_isFunction.default)(rawDefaultProp.render)) {
    isElement = true;
  } else if (rawDefaultProp.prototype != null && (0, import_isFunction.default)(rawDefaultProp.prototype.render)) {
    isElement = true;
  } else {
    var innerElement;
    try {
      inspectionResult = inspectValue(rawDefaultProp.toString());
      var _ref = inspectionResult.inferredType, hasParams = _ref.hasParams, params = _ref.params;
      if (hasParams) {
        if (params.length === 1 && params[0].type === "ObjectPattern") {
          innerElement = rawDefaultProp({});
        }
      } else {
        innerElement = rawDefaultProp();
      }
      if (innerElement != null) {
        if (isReactElement(innerElement)) {
          isElement = true;
        }
      }
    } catch (e) {
    }
  }
  var funcName = extractFunctionName(rawDefaultProp, propDef.name);
  if (funcName != null) {
    if (isElement) {
      return createSummaryValue(getPrettyElementIdentifier(funcName));
    }
    if (inspectionResult != null) {
      inspectionResult = inspectValue(rawDefaultProp.toString());
    }
    var _ref2 = inspectionResult.inferredType, _hasParams = _ref2.hasParams;
    return createSummaryValue(getPrettyFuncIdentifier(funcName, _hasParams));
  }
  return createSummaryValue(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var defaultResolver = function defaultResolver2(rawDefaultProp) {
  return createSummaryValue(rawDefaultProp.toString());
};
var DEFAULT_TYPE_RESOLVERS = {
  string: stringResolver,
  object: objectResolver,
  function: functionResolver,
  default: defaultResolver
};
function createTypeResolvers() {
  var customResolvers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.assign({}, DEFAULT_TYPE_RESOLVERS, customResolvers);
}
function createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef) {
  var typeResolvers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_TYPE_RESOLVERS;
  try {
    switch (_typeof2(rawDefaultProp)) {
      case "string":
        return typeResolvers.string(rawDefaultProp, propDef);
      case "object":
        return typeResolvers.object(rawDefaultProp, propDef);
      case "function": {
        return typeResolvers.function(rawDefaultProp, propDef);
      }
      default:
        return typeResolvers.default(rawDefaultProp, propDef);
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/propTypes/sortProps.js
function keepOriginalDefinitionOrder(extractedProps, component) {
  var propTypes = component.propTypes;
  if (propTypes != null) {
    return Object.keys(propTypes).map(function(x) {
      return extractedProps.find(function(y) {
        return y.name === x;
      });
    }).filter(function(x) {
      return x;
    });
  }
  return extractedProps;
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/propTypes/rawDefaultPropResolvers.js
var funcResolver = function funcResolver2(rawDefaultProp, _ref) {
  var name = _ref.name, type = _ref.type;
  var isElement = type.summary === "element" || type.summary === "elementType";
  var funcName = extractFunctionName(rawDefaultProp, name);
  if (funcName != null) {
    if (isElement) {
      return createSummaryValue(getPrettyElementIdentifier(funcName));
    }
    var _ref2 = inspectValue(rawDefaultProp.toString()).inferredType, hasParams = _ref2.hasParams;
    return createSummaryValue(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return createSummaryValue(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var rawDefaultPropTypeResolvers = createTypeResolvers({
  function: funcResolver
});

// ../../node_modules/@storybook/react/dist/esm/client/docs/propTypes/handleProp.js
function enhancePropTypesProp(extractedProp, rawDefaultProp) {
  var propDef = extractedProp.propDef;
  var newtype = createType(extractedProp);
  if (newtype != null) {
    propDef.type = newtype;
  }
  var defaultValue = extractedProp.docgenInfo.defaultValue;
  if (defaultValue != null && defaultValue.value != null) {
    var newDefaultValue = createDefaultValue(defaultValue.value);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  } else if (rawDefaultProp != null) {
    var _newDefaultValue = createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef, rawDefaultPropTypeResolvers);
    if (_newDefaultValue != null) {
      propDef.defaultValue = _newDefaultValue;
    }
  }
  return propDef;
}
function enhancePropTypesProps(extractedProps, component) {
  var rawDefaultProps = component.defaultProps != null ? component.defaultProps : {};
  var enhancedProps = extractedProps.map(function(x) {
    return enhancePropTypesProp(x, rawDefaultProps[x.propDef.name]);
  });
  return keepOriginalDefinitionOrder(enhancedProps, component);
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/typeScript/handleProp.js
function enhanceTypeScriptProp(extractedProp, rawDefaultProp) {
  var propDef = extractedProp.propDef;
  var defaultValue = extractedProp.docgenInfo.defaultValue;
  if (defaultValue != null && defaultValue.value != null) {
    var newDefaultValue = createDefaultValue(defaultValue.value);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  } else if (rawDefaultProp != null) {
    var _newDefaultValue = createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef);
    if (_newDefaultValue != null) {
      propDef.defaultValue = _newDefaultValue;
    }
  }
  return propDef;
}
function enhanceTypeScriptProps(extractedProps) {
  return extractedProps.map(function(prop) {
    return enhanceTypeScriptProp(prop);
  });
}

// ../../node_modules/@storybook/react/dist/esm/client/docs/extractProps.js
var propTypesMap = /* @__PURE__ */ new Map();
Object.keys(import_prop_types.default).forEach(function(typeName) {
  var type = import_prop_types.default[typeName];
  propTypesMap.set(type, typeName);
  propTypesMap.set(type.isRequired, typeName);
});
function getPropDefs(component, section) {
  var processedComponent = component;
  if (!hasDocgen(component) && !component.propTypes && isMemo(component)) {
    processedComponent = component.type;
  }
  var extractedProps = extractComponentProps(processedComponent, section);
  if (extractedProps.length === 0) {
    return [];
  }
  switch (extractedProps[0].typeSystem) {
    case TypeSystem.JAVASCRIPT:
      return enhancePropTypesProps(extractedProps, component);
    case TypeSystem.TYPESCRIPT:
      return enhanceTypeScriptProps(extractedProps);
    default:
      return extractedProps.map(function(x) {
        return x.propDef;
      });
  }
}
var extractProps = function extractProps2(component) {
  return {
    rows: getPropDefs(component, "props")
  };
};

// ../../node_modules/@storybook/react/dist/esm/client/docs/extractArgTypes.js
var extractArgTypes = function extractArgTypes2(component) {
  if (component) {
    var _extractProps = extractProps(component), rows = _extractProps.rows;
    if (rows) {
      return rows.reduce(function(acc, row) {
        var name = row.name, description = row.description, type = row.type, sbType = row.sbType, defaultSummary = row.defaultValue, jsDocTags = row.jsDocTags, required = row.required;
        acc[name] = {
          name,
          description,
          type: Object.assign({
            required
          }, sbType),
          table: {
            type,
            jsDocTags,
            defaultValue: defaultSummary
          }
        };
        return acc;
      }, {});
    }
  }
  return null;
};

// ../../node_modules/@storybook/react/dist/esm/client/docs/jsxDecorator.js
var import_es_array_iterator3 = __toESM(require_es_array_iterator());
var import_es_string_iterator3 = __toESM(require_es_string_iterator());
var import_es_regexp_exec5 = __toESM(require_es_regexp_exec());
var import_react2 = __toESM(require_react());
var import_util_deprecate = __toESM(require_browser());
var _excluded = ["mdxType", "originalType", "children"];
var _templateObject;
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray2(arr);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
var applyBeforeRender = function applyBeforeRender2(domString, options) {
  if (typeof options.onBeforeRender !== "function") {
    return domString;
  }
  var deprecatedOnBeforeRender = (0, import_util_deprecate.default)(options.onBeforeRender, esm_default(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      StoryFn.parameters.jsx.onBeforeRender was deprecated.\n      Prefer StoryFn.parameters.jsx.transformSource instead.\n      See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-onbeforerender for details.\n    "]))));
  return deprecatedOnBeforeRender(domString);
};
var applyTransformSource = function applyTransformSource2(domString, options, context) {
  if (typeof options.transformSource !== "function") {
    return domString;
  }
  return options.transformSource(domString, context);
};
var renderJsx = function renderJsx2(code, options) {
  if (typeof code === "undefined") {
    logger.warn("Too many skip or undefined component");
    return null;
  }
  var renderedJSX = code;
  var Type = renderedJSX.type;
  for (var i = 0; i < options.skip; i += 1) {
    if (typeof renderedJSX === "undefined") {
      logger.warn("Cannot skip undefined element");
      return null;
    }
    if (import_react2.default.Children.count(renderedJSX) > 1) {
      logger.warn("Trying to skip an array of elements");
      return null;
    }
    if (typeof renderedJSX.props.children === "undefined") {
      logger.warn("Not enough children to skip elements.");
      if (typeof renderedJSX.type === "function" && renderedJSX.type.name === "") {
        renderedJSX = import_react2.default.createElement(Type, renderedJSX.props);
      }
    } else if (typeof renderedJSX.props.children === "function") {
      renderedJSX = renderedJSX.props.children();
    } else {
      renderedJSX = renderedJSX.props.children;
    }
  }
  var displayNameDefaults = typeof options.displayName === "string" ? {
    showFunctions: true,
    displayName: function displayName() {
      return options.displayName;
    }
  } : {
    displayName: function displayName(el) {
      return el.type.displayName || getDocgenSection(el.type, "displayName") || (el.type.name !== "_default" ? el.type.name : null) || (typeof el.type === "function" ? "No Display Name" : null) || (isForwardRef(el.type) ? el.type.render.name : null) || (isMemo(el.type) ? el.type.type.name : null) || el.type;
    }
  };
  var filterDefaults = {
    filterProps: function filterProps3(value, key) {
      return value !== void 0;
    }
  };
  var opts = Object.assign({}, displayNameDefaults, filterDefaults, options);
  var result = import_react2.default.Children.map(code, function(c) {
    var child = typeof c === "number" ? c.toString() : c;
    var string = applyBeforeRender(reactElementToJsxString(child, opts), options);
    if (string.indexOf("&quot;") > -1) {
      var matches = string.match(/\S+=\\"([^"]*)\\"/g);
      if (matches) {
        matches.forEach(function(match) {
          string = string.replace(match, match.replace(/&quot;/g, "'"));
        });
      }
    }
    return string;
  }).join("\n");
  return result.replace(/function\s+noRefCheck\(\)\s+\{\}/, "() => {}");
};
var defaultOpts = {
  skip: 0,
  showFunctions: false,
  enableBeautify: true,
  showDefaultProps: false
};
var skipJsxRender = function skipJsxRender2(context) {
  var _context$parameters$d;
  var sourceParams = context === null || context === void 0 ? void 0 : (_context$parameters$d = context.parameters.docs) === null || _context$parameters$d === void 0 ? void 0 : _context$parameters$d.source;
  var isArgsStory = context === null || context === void 0 ? void 0 : context.parameters.__isArgsStory;
  if ((sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.type) === SourceType.DYNAMIC) {
    return false;
  }
  return !isArgsStory || (sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.code) || (sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.type) === SourceType.CODE;
};
var isMdx = function isMdx2(node) {
  var _node$type, _node$props;
  return ((_node$type = node.type) === null || _node$type === void 0 ? void 0 : _node$type.displayName) === "MDXCreateElement" && !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.mdxType);
};
var mdxToJsx = function mdxToJsx2(node) {
  if (!isMdx(node))
    return node;
  var _node$props2 = node.props, mdxType = _node$props2.mdxType, originalType = _node$props2.originalType, children = _node$props2.children, rest = _objectWithoutProperties(_node$props2, _excluded);
  var jsxChildren = [];
  if (children) {
    var array = Array.isArray(children) ? children : [children];
    jsxChildren = array.map(mdxToJsx2);
  }
  return import_react2.createElement.apply(void 0, [originalType, rest].concat(_toConsumableArray2(jsxChildren)));
};
var jsxDecorator = function jsxDecorator2(storyFn, context) {
  var _context$parameters$d2, _context$parameters$d3;
  var channel = addons.getChannel();
  var skip = skipJsxRender(context);
  var story = storyFn();
  var jsx2 = "";
  useEffect(function() {
    if (!skip)
      channel.emit(SNIPPET_RENDERED, (context || {}).id, jsx2);
  });
  if (skip) {
    return story;
  }
  var options = Object.assign({}, defaultOpts, (context === null || context === void 0 ? void 0 : context.parameters.jsx) || {});
  var storyJsx = context !== null && context !== void 0 && (_context$parameters$d2 = context.parameters.docs) !== null && _context$parameters$d2 !== void 0 && (_context$parameters$d3 = _context$parameters$d2.source) !== null && _context$parameters$d3 !== void 0 && _context$parameters$d3.excludeDecorators ? context.originalStoryFn(context.args, context) : story;
  var sourceJsx = mdxToJsx(storyJsx);
  var rendered = renderJsx(sourceJsx, options);
  if (rendered) {
    jsx2 = applyTransformSource(rendered, options, context);
  }
  return story;
};

// ../../node_modules/@storybook/react/dist/esm/client/docs/config.js
var parameters = {
  docs: {
    inlineStories: true,
    prepareForInline: function prepareForInline(storyFn) {
      return storyFn();
    },
    extractArgTypes,
    extractComponentDescription
  }
};
var decorators = [jsxDecorator];
var argTypesEnhancers = [enhanceArgTypes];
export {
  argTypesEnhancers,
  decorators,
  parameters
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
//# sourceMappingURL=@storybook_react_dist_esm_client_docs_config.js.map
